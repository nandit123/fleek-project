"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const empty_pb_1 = require("google-protobuf/google/protobuf/empty_pb");
const SpaceServiceClientPb_1 = require("./definitions/SpaceServiceClientPb");
const space_pb_1 = require("./definitions/space_pb");
const DEFAULT_BUCKET = 'personal';
class SpaceClient {
    constructor(opts) {
        const { url, options, credentials, defaultBucket = DEFAULT_BUCKET, } = opts;
        this.defaultBucket = defaultBucket;
        this.instance = new SpaceServiceClientPb_1.SpaceApiClient(url, credentials, options);
    }
    listDirectory(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.ListDirectoryRequest();
            const path = payload.path.replace(/^\//, '');
            const bucket = payload.bucket === '' ? null : payload.bucket;
            request.setPath(path);
            request.setBucket(bucket || this.defaultBucket);
            this.instance.listDirectory(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    listDirectories(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.ListDirectoriesRequest();
            const bucket = payload.bucket === '' ? null : payload.bucket;
            request.setBucket(bucket || this.defaultBucket);
            this.instance.listDirectories(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    toggleBucketBackup(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.ToggleBucketBackupRequest();
            const { backup, bucket } = payload;
            request.setBucket(bucket);
            request.setBackup(backup);
            this.instance.toggleBucketBackup(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    fileInfoSubscribe(metadata = {}) {
        const request = new empty_pb_1.Empty();
        return this.instance.fileInfoSubscribe(request, metadata);
    }
    txlSubscribe(metadata = {}) {
        const request = new empty_pb_1.Empty();
        return this.instance.txlSubscribe(request, metadata);
    }
    openFile(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.OpenFileRequest();
            const path = payload.path.replace(/^\//, '');
            const bucket = payload.bucket === '' ? null : payload.bucket;
            request.setPath(path);
            request.setBucket(bucket || this.defaultBucket);
            if (payload.dbId) {
                request.setDbid(payload.dbId);
            }
            this.instance.openFile(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    createBucket(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.CreateBucketRequest();
            request.setSlug(payload.slug);
            this.instance.createBucket(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    addItems(payload, metadata = {}) {
        const request = new space_pb_1.AddItemsRequest();
        const targetPath = payload.targetPath.replace(/^\//, '');
        const bucket = payload.bucket === '' ? null : payload.bucket;
        request.setTargetpath(targetPath);
        request.setSourcepathsList(payload.sourcePaths);
        request.setBucket(bucket || this.defaultBucket);
        const stream = this.instance.addItems(request, metadata);
        return stream;
    }
    createFolder(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.CreateFolderRequest();
            const path = payload.path.replace(/^\//, '');
            const bucket = payload.bucket === '' ? null : payload.bucket;
            request.setPath(path);
            request.setBucket(bucket || this.defaultBucket);
            this.instance.createFolder(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    backupKeysByPassphrase(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.BackupKeysByPassphraseRequest();
            request.setUuid(payload.uuid);
            request.setPassphrase(payload.passphrase);
            this.instance.backupKeysByPassphrase(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    recoverKeysByPassphrase(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.RecoverKeysByPassphraseRequest();
            request.setUuid(payload.uuid);
            request.setPassphrase(payload.passphrase);
            this.instance.recoverKeysByPassphrase(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    /**
     * [WIP] toggleFuseDrive
     *
     * Not supported by space daemon
     */
    toggleFuseDrive(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.ToggleFuseRequest();
            request.setMountdrive(payload.mountDrive);
            this.instance.toggleFuseDrive(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    /**
     * [WIP] getFuseDriveStatus
     *
     * Not supported by space daemon
     */
    getFuseDriveStatus(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new empty_pb_1.Empty();
            this.instance.getFuseDriveStatus(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    subscribe(metadata = {}) {
        const request = new empty_pb_1.Empty();
        return this.instance.subscribe(request, metadata);
    }
    /**
     * [WIP] listBuckets
     *
     * Not supported by space daemon
     */
    listBuckets(metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.ListBucketsRequest();
            this.instance.listBuckets(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    shareBucket(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.ShareBucketRequest();
            const bucket = payload.bucket === '' ? null : payload.bucket;
            request.setBucket(bucket || this.defaultBucket);
            this.instance.shareBucket(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    joinBucket(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const threadInfo = new space_pb_1.ThreadInfo();
            threadInfo.setKey(payload.threadInfo.key);
            threadInfo.setAddressesList(payload.threadInfo.addresses);
            const request = new space_pb_1.JoinBucketRequest();
            const bucket = payload.bucket === '' ? null : payload.bucket;
            request.setThreadinfo(threadInfo);
            request.setBucket(bucket || this.defaultBucket);
            this.instance.joinBucket(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    setNotificationsLastSeenAt(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.SetNotificationsLastSeenAtRequest();
            request.setTimestamp(payload.timestamp);
            this.instance.setNotificationsLastSeenAt(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    getNotifications(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.GetNotificationsRequest();
            request.setSeek(payload.seek);
            request.setLimit(payload.limit);
            this.instance.getNotifications(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    handleFilesInvitation(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.HandleFilesInvitationRequest();
            request.setInvitationid(payload.invitationID);
            request.setAccept(payload.accept);
            this.instance.handleFilesInvitation(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    getPublicKey(metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.GetPublicKeyRequest();
            this.instance.getPublicKey(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    notificationSubscribe(metadata = {}) {
        const request = new empty_pb_1.Empty();
        return this.instance.notificationSubscribe(request, metadata);
    }
    readNotification(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.ReadNotificationRequest();
            request.setId(payload.ID);
            this.instance.readNotification(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    deleteAccount(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    payload = null, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.DeleteAccountRequest();
            this.instance.deleteAccount(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    deleteKeyPair(metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.DeleteKeyPairRequest();
            this.instance.deleteKeyPair(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    getUsageInfo(metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.GetUsageInfoRequest();
            this.instance.getUsageInfo(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    getStoredMnemonic(metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.GetStoredMnemonicRequest();
            this.instance.getStoredMnemonic(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    restoreKeyPairViaMnemonic(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.RestoreKeyPairViaMnemonicRequest();
            request.setMnemonic(payload.mnemonic);
            this.instance.restoreKeyPairViaMnemonic(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    getSharedWithMeFiles(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.GetSharedWithMeFilesRequest();
            request.setSeek(payload.seek);
            request.setLimit(payload.limit);
            this.instance.getSharedWithMeFiles(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    shareFilesViaPublicKey(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.ShareFilesViaPublicKeyRequest();
            const paths = payload.paths.map((path) => {
                const fullPath = new space_pb_1.FullPath();
                const bucket = path.bucket === '' ? null : path.bucket;
                fullPath.setBucket(bucket || this.defaultBucket);
                fullPath.setPath(path.path);
                if (path.dbId) {
                    fullPath.setDbid(path.dbId);
                }
                return fullPath;
            });
            request.setPathsList(paths);
            request.setPublickeysList(payload.publicKeys);
            this.instance.shareFilesViaPublicKey(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    getAPISessionTokens(metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.GetAPISessionTokensRequest();
            this.instance.getAPISessionTokens(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    getRecentlySharedWith(metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.GetRecentlySharedWithRequest();
            this.instance.getRecentlySharedWith(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    generatePublicFileLink(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.GeneratePublicFileLinkRequest();
            const bucket = payload.bucket === '' ? null : payload.bucket;
            const itemPaths = payload.itemPaths.map((path) => path.replace(/^\//, ''));
            request.setDbid(payload.dbId);
            request.setPassword(payload.password);
            request.setItempathsList(itemPaths);
            request.setBucket(bucket || this.defaultBucket);
            this.instance.generatePublicFileLink(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    testKeysPassphrase(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.TestKeysPassphraseRequest();
            request.setUuid(payload.uuid);
            request.setPassphrase(payload.passphrase);
            this.instance.testKeysPassphrase(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    generateKeyPairWithForce(metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.GenerateKeyPairRequest();
            this.instance.generateKeyPairWithForce(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
}
exports.default = SpaceClient;
//# sourceMappingURL=client.js.map